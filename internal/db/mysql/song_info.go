// Code generated by SQLBoiler 4.15.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package mysql

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// SongInfo is an object representing the database table.
type SongInfo struct {
	SongInfoID      int64        `boil:"song_info_id" json:"song_info_id" toml:"song_info_id" yaml:"song_info_id"`
	SongName        string       `boil:"song_name" json:"song_name" toml:"song_name" yaml:"song_name"`
	ArtistName      string       `boil:"artist_name" json:"artist_name" toml:"artist_name" yaml:"artist_name"`
	ArtistType      null.String  `boil:"artist_type" json:"artist_type,omitempty" toml:"artist_type" yaml:"artist_type,omitempty"`
	IsMR            null.Bool    `boil:"is_mr" json:"is_mr,omitempty" toml:"is_mr" yaml:"is_mr,omitempty"`
	IsChosen22000   null.Bool    `boil:"is_chosen_22000" json:"is_chosen_22000,omitempty" toml:"is_chosen_22000" yaml:"is_chosen_22000,omitempty"`
	RelatedArtists  null.String  `boil:"related_artists" json:"related_artists,omitempty" toml:"related_artists" yaml:"related_artists,omitempty"`
	Country         null.String  `boil:"country" json:"country,omitempty" toml:"country" yaml:"country,omitempty"`
	Album           null.String  `boil:"album" json:"album,omitempty" toml:"album" yaml:"album,omitempty"`
	SongNumber      int          `boil:"song_number" json:"song_number" toml:"song_number" yaml:"song_number"`
	TJLink          null.String  `boil:"tj_link" json:"tj_link,omitempty" toml:"tj_link" yaml:"tj_link,omitempty"`
	CreatedAt       null.Time    `boil:"created_at" json:"created_at,omitempty" toml:"created_at" yaml:"created_at,omitempty"`
	UpdatedAt       null.Time    `boil:"updated_at" json:"updated_at,omitempty" toml:"updated_at" yaml:"updated_at,omitempty"`
	DeletedAt       null.Time    `boil:"deleted_at" json:"deleted_at,omitempty" toml:"deleted_at" yaml:"deleted_at,omitempty"`
	MelonSongID     null.String  `boil:"melon_song_id" json:"melon_song_id,omitempty" toml:"melon_song_id" yaml:"melon_song_id,omitempty"`
	IsLive          null.Bool    `boil:"is_live" json:"is_live,omitempty" toml:"is_live" yaml:"is_live,omitempty"`
	TJScore         null.Float32 `boil:"tj_score" json:"tj_score,omitempty" toml:"tj_score" yaml:"tj_score,omitempty"`
	Genre           null.String  `boil:"genre" json:"genre,omitempty" toml:"genre" yaml:"genre,omitempty"`
	Year            null.Int     `boil:"year" json:"year,omitempty" toml:"year" yaml:"year,omitempty"`
	LyricsVideoLink null.String  `boil:"lyrics_video_link" json:"lyrics_video_link,omitempty" toml:"lyrics_video_link" yaml:"lyrics_video_link,omitempty"`
	ArtistGender    null.String  `boil:"artist_gender" json:"artist_gender,omitempty" toml:"artist_gender" yaml:"artist_gender,omitempty"`
	Octave          null.String  `boil:"octave" json:"octave,omitempty" toml:"octave" yaml:"octave,omitempty"`
	TJYoutubeLink   null.String  `boil:"tj_youtube_link" json:"tj_youtube_link,omitempty" toml:"tj_youtube_link" yaml:"tj_youtube_link,omitempty"`
	Classics        null.Bool    `boil:"classics" json:"classics,omitempty" toml:"classics" yaml:"classics,omitempty"`
	Finale          null.Bool    `boil:"finale" json:"finale,omitempty" toml:"finale" yaml:"finale,omitempty"`
	High            null.Bool    `boil:"high" json:"high,omitempty" toml:"high" yaml:"high,omitempty"`
	Low             null.Bool    `boil:"low" json:"low,omitempty" toml:"low" yaml:"low,omitempty"`
	RNB             null.Bool    `boil:"rnb" json:"rnb,omitempty" toml:"rnb" yaml:"rnb,omitempty"`
	Breakup         null.Bool    `boil:"breakup" json:"breakup,omitempty" toml:"breakup" yaml:"breakup,omitempty"`
	Ballads         null.Bool    `boil:"ballads" json:"ballads,omitempty" toml:"ballads" yaml:"ballads,omitempty"`
	Dance           null.Bool    `boil:"dance" json:"dance,omitempty" toml:"dance" yaml:"dance,omitempty"`
	Duet            null.Bool    `boil:"duet" json:"duet,omitempty" toml:"duet" yaml:"duet,omitempty"`
	Ssum            null.Bool    `boil:"ssum" json:"ssum,omitempty" toml:"ssum" yaml:"ssum,omitempty"`
	Carol           null.Bool    `boil:"carol" json:"carol,omitempty" toml:"carol" yaml:"carol,omitempty"`
	Rainy           null.Bool    `boil:"rainy" json:"rainy,omitempty" toml:"rainy" yaml:"rainy,omitempty"`
	Pop             null.Bool    `boil:"pop" json:"pop,omitempty" toml:"pop" yaml:"pop,omitempty"`
	Office          null.Bool    `boil:"office" json:"office,omitempty" toml:"office" yaml:"office,omitempty"`
	Wedding         null.Bool    `boil:"wedding" json:"wedding,omitempty" toml:"wedding" yaml:"wedding,omitempty"`
	Military        null.Bool    `boil:"military" json:"military,omitempty" toml:"military" yaml:"military,omitempty"`
	ArtistIds       null.String  `boil:"artist_ids" json:"artist_ids,omitempty" toml:"artist_ids" yaml:"artist_ids,omitempty"`
	MelonLikes      null.Int     `boil:"melon_likes" json:"melon_likes,omitempty" toml:"melon_likes" yaml:"melon_likes,omitempty"`
	LyricsSummary   null.String  `boil:"lyrics_summary" json:"lyrics_summary,omitempty" toml:"lyrics_summary" yaml:"lyrics_summary,omitempty"`
	Hiphop          null.Bool    `boil:"hiphop" json:"hiphop,omitempty" toml:"hiphop" yaml:"hiphop,omitempty"`
	Jpop            null.Bool    `boil:"jpop" json:"jpop,omitempty" toml:"jpop" yaml:"jpop,omitempty"`
	Musical         null.Bool    `boil:"musical" json:"musical,omitempty" toml:"musical" yaml:"musical,omitempty"`
	Band            null.Bool    `boil:"band" json:"band,omitempty" toml:"band" yaml:"band,omitempty"`

	R *songInfoR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L songInfoL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var SongInfoColumns = struct {
	SongInfoID      string
	SongName        string
	ArtistName      string
	ArtistType      string
	IsMR            string
	IsChosen22000   string
	RelatedArtists  string
	Country         string
	Album           string
	SongNumber      string
	TJLink          string
	CreatedAt       string
	UpdatedAt       string
	DeletedAt       string
	MelonSongID     string
	IsLive          string
	TJScore         string
	Genre           string
	Year            string
	LyricsVideoLink string
	ArtistGender    string
	Octave          string
	TJYoutubeLink   string
	Classics        string
	Finale          string
	High            string
	Low             string
	RNB             string
	Breakup         string
	Ballads         string
	Dance           string
	Duet            string
	Ssum            string
	Carol           string
	Rainy           string
	Pop             string
	Office          string
	Wedding         string
	Military        string
	ArtistIds       string
	MelonLikes      string
	LyricsSummary   string
	Hiphop          string
	Jpop            string
	Musical         string
	Band            string
}{
	SongInfoID:      "song_info_id",
	SongName:        "song_name",
	ArtistName:      "artist_name",
	ArtistType:      "artist_type",
	IsMR:            "is_mr",
	IsChosen22000:   "is_chosen_22000",
	RelatedArtists:  "related_artists",
	Country:         "country",
	Album:           "album",
	SongNumber:      "song_number",
	TJLink:          "tj_link",
	CreatedAt:       "created_at",
	UpdatedAt:       "updated_at",
	DeletedAt:       "deleted_at",
	MelonSongID:     "melon_song_id",
	IsLive:          "is_live",
	TJScore:         "tj_score",
	Genre:           "genre",
	Year:            "year",
	LyricsVideoLink: "lyrics_video_link",
	ArtistGender:    "artist_gender",
	Octave:          "octave",
	TJYoutubeLink:   "tj_youtube_link",
	Classics:        "classics",
	Finale:          "finale",
	High:            "high",
	Low:             "low",
	RNB:             "rnb",
	Breakup:         "breakup",
	Ballads:         "ballads",
	Dance:           "dance",
	Duet:            "duet",
	Ssum:            "ssum",
	Carol:           "carol",
	Rainy:           "rainy",
	Pop:             "pop",
	Office:          "office",
	Wedding:         "wedding",
	Military:        "military",
	ArtistIds:       "artist_ids",
	MelonLikes:      "melon_likes",
	LyricsSummary:   "lyrics_summary",
	Hiphop:          "hiphop",
	Jpop:            "jpop",
	Musical:         "musical",
	Band:            "band",
}

var SongInfoTableColumns = struct {
	SongInfoID      string
	SongName        string
	ArtistName      string
	ArtistType      string
	IsMR            string
	IsChosen22000   string
	RelatedArtists  string
	Country         string
	Album           string
	SongNumber      string
	TJLink          string
	CreatedAt       string
	UpdatedAt       string
	DeletedAt       string
	MelonSongID     string
	IsLive          string
	TJScore         string
	Genre           string
	Year            string
	LyricsVideoLink string
	ArtistGender    string
	Octave          string
	TJYoutubeLink   string
	Classics        string
	Finale          string
	High            string
	Low             string
	RNB             string
	Breakup         string
	Ballads         string
	Dance           string
	Duet            string
	Ssum            string
	Carol           string
	Rainy           string
	Pop             string
	Office          string
	Wedding         string
	Military        string
	ArtistIds       string
	MelonLikes      string
	LyricsSummary   string
	Hiphop          string
	Jpop            string
	Musical         string
	Band            string
}{
	SongInfoID:      "song_info.song_info_id",
	SongName:        "song_info.song_name",
	ArtistName:      "song_info.artist_name",
	ArtistType:      "song_info.artist_type",
	IsMR:            "song_info.is_mr",
	IsChosen22000:   "song_info.is_chosen_22000",
	RelatedArtists:  "song_info.related_artists",
	Country:         "song_info.country",
	Album:           "song_info.album",
	SongNumber:      "song_info.song_number",
	TJLink:          "song_info.tj_link",
	CreatedAt:       "song_info.created_at",
	UpdatedAt:       "song_info.updated_at",
	DeletedAt:       "song_info.deleted_at",
	MelonSongID:     "song_info.melon_song_id",
	IsLive:          "song_info.is_live",
	TJScore:         "song_info.tj_score",
	Genre:           "song_info.genre",
	Year:            "song_info.year",
	LyricsVideoLink: "song_info.lyrics_video_link",
	ArtistGender:    "song_info.artist_gender",
	Octave:          "song_info.octave",
	TJYoutubeLink:   "song_info.tj_youtube_link",
	Classics:        "song_info.classics",
	Finale:          "song_info.finale",
	High:            "song_info.high",
	Low:             "song_info.low",
	RNB:             "song_info.rnb",
	Breakup:         "song_info.breakup",
	Ballads:         "song_info.ballads",
	Dance:           "song_info.dance",
	Duet:            "song_info.duet",
	Ssum:            "song_info.ssum",
	Carol:           "song_info.carol",
	Rainy:           "song_info.rainy",
	Pop:             "song_info.pop",
	Office:          "song_info.office",
	Wedding:         "song_info.wedding",
	Military:        "song_info.military",
	ArtistIds:       "song_info.artist_ids",
	MelonLikes:      "song_info.melon_likes",
	LyricsSummary:   "song_info.lyrics_summary",
	Hiphop:          "song_info.hiphop",
	Jpop:            "song_info.jpop",
	Musical:         "song_info.musical",
	Band:            "song_info.band",
}

// Generated where

type whereHelpernull_Float32 struct{ field string }

func (w whereHelpernull_Float32) EQ(x null.Float32) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Float32) NEQ(x null.Float32) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Float32) LT(x null.Float32) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Float32) LTE(x null.Float32) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Float32) GT(x null.Float32) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Float32) GTE(x null.Float32) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}
func (w whereHelpernull_Float32) IN(slice []float32) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelpernull_Float32) NIN(slice []float32) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

func (w whereHelpernull_Float32) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Float32) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

var SongInfoWhere = struct {
	SongInfoID      whereHelperint64
	SongName        whereHelperstring
	ArtistName      whereHelperstring
	ArtistType      whereHelpernull_String
	IsMR            whereHelpernull_Bool
	IsChosen22000   whereHelpernull_Bool
	RelatedArtists  whereHelpernull_String
	Country         whereHelpernull_String
	Album           whereHelpernull_String
	SongNumber      whereHelperint
	TJLink          whereHelpernull_String
	CreatedAt       whereHelpernull_Time
	UpdatedAt       whereHelpernull_Time
	DeletedAt       whereHelpernull_Time
	MelonSongID     whereHelpernull_String
	IsLive          whereHelpernull_Bool
	TJScore         whereHelpernull_Float32
	Genre           whereHelpernull_String
	Year            whereHelpernull_Int
	LyricsVideoLink whereHelpernull_String
	ArtistGender    whereHelpernull_String
	Octave          whereHelpernull_String
	TJYoutubeLink   whereHelpernull_String
	Classics        whereHelpernull_Bool
	Finale          whereHelpernull_Bool
	High            whereHelpernull_Bool
	Low             whereHelpernull_Bool
	RNB             whereHelpernull_Bool
	Breakup         whereHelpernull_Bool
	Ballads         whereHelpernull_Bool
	Dance           whereHelpernull_Bool
	Duet            whereHelpernull_Bool
	Ssum            whereHelpernull_Bool
	Carol           whereHelpernull_Bool
	Rainy           whereHelpernull_Bool
	Pop             whereHelpernull_Bool
	Office          whereHelpernull_Bool
	Wedding         whereHelpernull_Bool
	Military        whereHelpernull_Bool
	ArtistIds       whereHelpernull_String
	MelonLikes      whereHelpernull_Int
	LyricsSummary   whereHelpernull_String
	Hiphop          whereHelpernull_Bool
	Jpop            whereHelpernull_Bool
	Musical         whereHelpernull_Bool
	Band            whereHelpernull_Bool
}{
	SongInfoID:      whereHelperint64{field: "`song_info`.`song_info_id`"},
	SongName:        whereHelperstring{field: "`song_info`.`song_name`"},
	ArtistName:      whereHelperstring{field: "`song_info`.`artist_name`"},
	ArtistType:      whereHelpernull_String{field: "`song_info`.`artist_type`"},
	IsMR:            whereHelpernull_Bool{field: "`song_info`.`is_mr`"},
	IsChosen22000:   whereHelpernull_Bool{field: "`song_info`.`is_chosen_22000`"},
	RelatedArtists:  whereHelpernull_String{field: "`song_info`.`related_artists`"},
	Country:         whereHelpernull_String{field: "`song_info`.`country`"},
	Album:           whereHelpernull_String{field: "`song_info`.`album`"},
	SongNumber:      whereHelperint{field: "`song_info`.`song_number`"},
	TJLink:          whereHelpernull_String{field: "`song_info`.`tj_link`"},
	CreatedAt:       whereHelpernull_Time{field: "`song_info`.`created_at`"},
	UpdatedAt:       whereHelpernull_Time{field: "`song_info`.`updated_at`"},
	DeletedAt:       whereHelpernull_Time{field: "`song_info`.`deleted_at`"},
	MelonSongID:     whereHelpernull_String{field: "`song_info`.`melon_song_id`"},
	IsLive:          whereHelpernull_Bool{field: "`song_info`.`is_live`"},
	TJScore:         whereHelpernull_Float32{field: "`song_info`.`tj_score`"},
	Genre:           whereHelpernull_String{field: "`song_info`.`genre`"},
	Year:            whereHelpernull_Int{field: "`song_info`.`year`"},
	LyricsVideoLink: whereHelpernull_String{field: "`song_info`.`lyrics_video_link`"},
	ArtistGender:    whereHelpernull_String{field: "`song_info`.`artist_gender`"},
	Octave:          whereHelpernull_String{field: "`song_info`.`octave`"},
	TJYoutubeLink:   whereHelpernull_String{field: "`song_info`.`tj_youtube_link`"},
	Classics:        whereHelpernull_Bool{field: "`song_info`.`classics`"},
	Finale:          whereHelpernull_Bool{field: "`song_info`.`finale`"},
	High:            whereHelpernull_Bool{field: "`song_info`.`high`"},
	Low:             whereHelpernull_Bool{field: "`song_info`.`low`"},
	RNB:             whereHelpernull_Bool{field: "`song_info`.`rnb`"},
	Breakup:         whereHelpernull_Bool{field: "`song_info`.`breakup`"},
	Ballads:         whereHelpernull_Bool{field: "`song_info`.`ballads`"},
	Dance:           whereHelpernull_Bool{field: "`song_info`.`dance`"},
	Duet:            whereHelpernull_Bool{field: "`song_info`.`duet`"},
	Ssum:            whereHelpernull_Bool{field: "`song_info`.`ssum`"},
	Carol:           whereHelpernull_Bool{field: "`song_info`.`carol`"},
	Rainy:           whereHelpernull_Bool{field: "`song_info`.`rainy`"},
	Pop:             whereHelpernull_Bool{field: "`song_info`.`pop`"},
	Office:          whereHelpernull_Bool{field: "`song_info`.`office`"},
	Wedding:         whereHelpernull_Bool{field: "`song_info`.`wedding`"},
	Military:        whereHelpernull_Bool{field: "`song_info`.`military`"},
	ArtistIds:       whereHelpernull_String{field: "`song_info`.`artist_ids`"},
	MelonLikes:      whereHelpernull_Int{field: "`song_info`.`melon_likes`"},
	LyricsSummary:   whereHelpernull_String{field: "`song_info`.`lyrics_summary`"},
	Hiphop:          whereHelpernull_Bool{field: "`song_info`.`hiphop`"},
	Jpop:            whereHelpernull_Bool{field: "`song_info`.`jpop`"},
	Musical:         whereHelpernull_Bool{field: "`song_info`.`musical`"},
	Band:            whereHelpernull_Bool{field: "`song_info`.`band`"},
}

// SongInfoRels is where relationship names are stored.
var SongInfoRels = struct {
}{}

// songInfoR is where relationships are stored.
type songInfoR struct {
}

// NewStruct creates a new relationship struct
func (*songInfoR) NewStruct() *songInfoR {
	return &songInfoR{}
}

// songInfoL is where Load methods for each relationship are stored.
type songInfoL struct{}

var (
	songInfoAllColumns            = []string{"song_info_id", "song_name", "artist_name", "artist_type", "is_mr", "is_chosen_22000", "related_artists", "country", "album", "song_number", "tj_link", "created_at", "updated_at", "deleted_at", "melon_song_id", "is_live", "tj_score", "genre", "year", "lyrics_video_link", "artist_gender", "octave", "tj_youtube_link", "classics", "finale", "high", "low", "rnb", "breakup", "ballads", "dance", "duet", "ssum", "carol", "rainy", "pop", "office", "wedding", "military", "artist_ids", "melon_likes", "lyrics_summary", "hiphop", "jpop", "musical", "band"}
	songInfoColumnsWithoutDefault = []string{"song_name", "artist_name", "artist_type", "related_artists", "country", "album", "song_number", "tj_link", "deleted_at", "melon_song_id", "genre", "year", "lyrics_video_link", "artist_gender", "octave", "tj_youtube_link", "artist_ids", "melon_likes", "lyrics_summary"}
	songInfoColumnsWithDefault    = []string{"song_info_id", "is_mr", "is_chosen_22000", "created_at", "updated_at", "is_live", "tj_score", "classics", "finale", "high", "low", "rnb", "breakup", "ballads", "dance", "duet", "ssum", "carol", "rainy", "pop", "office", "wedding", "military", "hiphop", "jpop", "musical", "band"}
	songInfoPrimaryKeyColumns     = []string{"song_info_id"}
	songInfoGeneratedColumns      = []string{}
)

type (
	// SongInfoSlice is an alias for a slice of pointers to SongInfo.
	// This should almost always be used instead of []SongInfo.
	SongInfoSlice []*SongInfo
	// SongInfoHook is the signature for custom SongInfo hook methods
	SongInfoHook func(context.Context, boil.ContextExecutor, *SongInfo) error

	songInfoQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	songInfoType                 = reflect.TypeOf(&SongInfo{})
	songInfoMapping              = queries.MakeStructMapping(songInfoType)
	songInfoPrimaryKeyMapping, _ = queries.BindMapping(songInfoType, songInfoMapping, songInfoPrimaryKeyColumns)
	songInfoInsertCacheMut       sync.RWMutex
	songInfoInsertCache          = make(map[string]insertCache)
	songInfoUpdateCacheMut       sync.RWMutex
	songInfoUpdateCache          = make(map[string]updateCache)
	songInfoUpsertCacheMut       sync.RWMutex
	songInfoUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var songInfoAfterSelectHooks []SongInfoHook

var songInfoBeforeInsertHooks []SongInfoHook
var songInfoAfterInsertHooks []SongInfoHook

var songInfoBeforeUpdateHooks []SongInfoHook
var songInfoAfterUpdateHooks []SongInfoHook

var songInfoBeforeDeleteHooks []SongInfoHook
var songInfoAfterDeleteHooks []SongInfoHook

var songInfoBeforeUpsertHooks []SongInfoHook
var songInfoAfterUpsertHooks []SongInfoHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *SongInfo) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range songInfoAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *SongInfo) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range songInfoBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *SongInfo) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range songInfoAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *SongInfo) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range songInfoBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *SongInfo) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range songInfoAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *SongInfo) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range songInfoBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *SongInfo) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range songInfoAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *SongInfo) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range songInfoBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *SongInfo) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range songInfoAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddSongInfoHook registers your hook function for all future operations.
func AddSongInfoHook(hookPoint boil.HookPoint, songInfoHook SongInfoHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		songInfoAfterSelectHooks = append(songInfoAfterSelectHooks, songInfoHook)
	case boil.BeforeInsertHook:
		songInfoBeforeInsertHooks = append(songInfoBeforeInsertHooks, songInfoHook)
	case boil.AfterInsertHook:
		songInfoAfterInsertHooks = append(songInfoAfterInsertHooks, songInfoHook)
	case boil.BeforeUpdateHook:
		songInfoBeforeUpdateHooks = append(songInfoBeforeUpdateHooks, songInfoHook)
	case boil.AfterUpdateHook:
		songInfoAfterUpdateHooks = append(songInfoAfterUpdateHooks, songInfoHook)
	case boil.BeforeDeleteHook:
		songInfoBeforeDeleteHooks = append(songInfoBeforeDeleteHooks, songInfoHook)
	case boil.AfterDeleteHook:
		songInfoAfterDeleteHooks = append(songInfoAfterDeleteHooks, songInfoHook)
	case boil.BeforeUpsertHook:
		songInfoBeforeUpsertHooks = append(songInfoBeforeUpsertHooks, songInfoHook)
	case boil.AfterUpsertHook:
		songInfoAfterUpsertHooks = append(songInfoAfterUpsertHooks, songInfoHook)
	}
}

// One returns a single songInfo record from the query.
func (q songInfoQuery) One(ctx context.Context, exec boil.ContextExecutor) (*SongInfo, error) {
	o := &SongInfo{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "mysql: failed to execute a one query for song_info")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all SongInfo records from the query.
func (q songInfoQuery) All(ctx context.Context, exec boil.ContextExecutor) (SongInfoSlice, error) {
	var o []*SongInfo

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "mysql: failed to assign all query results to SongInfo slice")
	}

	if len(songInfoAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all SongInfo records in the query.
func (q songInfoQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "mysql: failed to count song_info rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q songInfoQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "mysql: failed to check if song_info exists")
	}

	return count > 0, nil
}

// SongInfos retrieves all the records using an executor.
func SongInfos(mods ...qm.QueryMod) songInfoQuery {
	mods = append(mods, qm.From("`song_info`"))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"`song_info`.*"})
	}

	return songInfoQuery{q}
}

// FindSongInfo retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindSongInfo(ctx context.Context, exec boil.ContextExecutor, songInfoID int64, selectCols ...string) (*SongInfo, error) {
	songInfoObj := &SongInfo{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `song_info` where `song_info_id`=?", sel,
	)

	q := queries.Raw(query, songInfoID)

	err := q.Bind(ctx, exec, songInfoObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "mysql: unable to select from song_info")
	}

	if err = songInfoObj.doAfterSelectHooks(ctx, exec); err != nil {
		return songInfoObj, err
	}

	return songInfoObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *SongInfo) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("mysql: no song_info provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(songInfoColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	songInfoInsertCacheMut.RLock()
	cache, cached := songInfoInsertCache[key]
	songInfoInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			songInfoAllColumns,
			songInfoColumnsWithDefault,
			songInfoColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(songInfoType, songInfoMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(songInfoType, songInfoMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `song_info` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `song_info` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `song_info` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, songInfoPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "mysql: unable to insert into song_info")
	}

	var lastID int64
	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.SongInfoID = int64(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == songInfoMapping["song_info_id"] {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.SongInfoID,
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, identifierCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "mysql: unable to populate default values for song_info")
	}

CacheNoHooks:
	if !cached {
		songInfoInsertCacheMut.Lock()
		songInfoInsertCache[key] = cache
		songInfoInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the SongInfo.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *SongInfo) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	songInfoUpdateCacheMut.RLock()
	cache, cached := songInfoUpdateCache[key]
	songInfoUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			songInfoAllColumns,
			songInfoPrimaryKeyColumns,
		)
		if len(wl) == 0 {
			return 0, errors.New("mysql: unable to update song_info, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `song_info` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, songInfoPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(songInfoType, songInfoMapping, append(wl, songInfoPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "mysql: unable to update song_info row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "mysql: failed to get rows affected by update for song_info")
	}

	if !cached {
		songInfoUpdateCacheMut.Lock()
		songInfoUpdateCache[key] = cache
		songInfoUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q songInfoQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "mysql: unable to update all for song_info")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "mysql: unable to retrieve rows affected for song_info")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o SongInfoSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("mysql: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), songInfoPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `song_info` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, songInfoPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "mysql: unable to update all in songInfo slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "mysql: unable to retrieve rows affected all in update all songInfo")
	}
	return rowsAff, nil
}

var mySQLSongInfoUniqueColumns = []string{
	"song_info_id",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *SongInfo) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("mysql: no song_info provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(songInfoColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLSongInfoUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	songInfoUpsertCacheMut.RLock()
	cache, cached := songInfoUpsertCache[key]
	songInfoUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			songInfoAllColumns,
			songInfoColumnsWithDefault,
			songInfoColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			songInfoAllColumns,
			songInfoPrimaryKeyColumns,
		)

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("mysql: unable to upsert song_info, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "`song_info`", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `song_info` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(songInfoType, songInfoMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(songInfoType, songInfoMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "mysql: unable to upsert for song_info")
	}

	var lastID int64
	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.SongInfoID = int64(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == songInfoMapping["song_info_id"] {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(songInfoType, songInfoMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "mysql: unable to retrieve unique values for song_info")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, nzUniqueCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "mysql: unable to populate default values for song_info")
	}

CacheNoHooks:
	if !cached {
		songInfoUpsertCacheMut.Lock()
		songInfoUpsertCache[key] = cache
		songInfoUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single SongInfo record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *SongInfo) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("mysql: no SongInfo provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), songInfoPrimaryKeyMapping)
	sql := "DELETE FROM `song_info` WHERE `song_info_id`=?"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "mysql: unable to delete from song_info")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "mysql: failed to get rows affected by delete for song_info")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q songInfoQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("mysql: no songInfoQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "mysql: unable to delete all from song_info")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "mysql: failed to get rows affected by deleteall for song_info")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o SongInfoSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(songInfoBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), songInfoPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `song_info` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, songInfoPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "mysql: unable to delete all from songInfo slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "mysql: failed to get rows affected by deleteall for song_info")
	}

	if len(songInfoAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *SongInfo) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindSongInfo(ctx, exec, o.SongInfoID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *SongInfoSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := SongInfoSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), songInfoPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `song_info`.* FROM `song_info` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, songInfoPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "mysql: unable to reload all in SongInfoSlice")
	}

	*o = slice

	return nil
}

// SongInfoExists checks if the SongInfo row exists.
func SongInfoExists(ctx context.Context, exec boil.ContextExecutor, songInfoID int64) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `song_info` where `song_info_id`=? limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, songInfoID)
	}
	row := exec.QueryRowContext(ctx, sql, songInfoID)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "mysql: unable to check if song_info exists")
	}

	return exists, nil
}

// Exists checks if the SongInfo row exists.
func (o *SongInfo) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return SongInfoExists(ctx, exec, o.SongInfoID)
}
