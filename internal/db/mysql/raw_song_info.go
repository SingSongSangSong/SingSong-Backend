// Code generated by SQLBoiler 4.15.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package mysql

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// RawSongInfo is an object representing the database table.
type RawSongInfo struct {
	RawSongInfoID   int64       `boil:"raw_song_info_id" json:"raw_song_info_id" toml:"raw_song_info_id" yaml:"raw_song_info_id"`
	SongNumber      int         `boil:"song_number" json:"song_number" toml:"song_number" yaml:"song_number"`
	SongName        string      `boil:"song_name" json:"song_name" toml:"song_name" yaml:"song_name"`
	ArtistName      string      `boil:"artist_name" json:"artist_name" toml:"artist_name" yaml:"artist_name"`
	MelonSongID     null.String `boil:"melon_song_id" json:"melon_song_id,omitempty" toml:"melon_song_id" yaml:"melon_song_id,omitempty"`
	MelonArtistID   null.String `boil:"melon_artist_id" json:"melon_artist_id,omitempty" toml:"melon_artist_id" yaml:"melon_artist_id,omitempty"`
	MelonArtistName null.String `boil:"melon_artist_name" json:"melon_artist_name,omitempty" toml:"melon_artist_name" yaml:"melon_artist_name,omitempty"`
	Album           null.String `boil:"album" json:"album,omitempty" toml:"album" yaml:"album,omitempty"`
	Genre           null.String `boil:"genre" json:"genre,omitempty" toml:"genre" yaml:"genre,omitempty"`
	Lyrics          null.String `boil:"lyrics" json:"lyrics,omitempty" toml:"lyrics" yaml:"lyrics,omitempty"`
	LyricsSummary   null.String `boil:"lyrics_summary" json:"lyrics_summary,omitempty" toml:"lyrics_summary" yaml:"lyrics_summary,omitempty"`
	LyricsTags      null.String `boil:"lyrics_tags" json:"lyrics_tags,omitempty" toml:"lyrics_tags" yaml:"lyrics_tags,omitempty"`
	Year            null.String `boil:"year" json:"year,omitempty" toml:"year" yaml:"year,omitempty"`
	Country         null.String `boil:"country" json:"country,omitempty" toml:"country" yaml:"country,omitempty"`
	SingerType      null.String `boil:"singer_type" json:"singer_type,omitempty" toml:"singer_type" yaml:"singer_type,omitempty"`
	RelatedArtists  null.String `boil:"related_artists" json:"related_artists,omitempty" toml:"related_artists" yaml:"related_artists,omitempty"`
	CreatedAt       null.Time   `boil:"created_at" json:"created_at,omitempty" toml:"created_at" yaml:"created_at,omitempty"`
	UpdatedAt       null.Time   `boil:"updated_at" json:"updated_at,omitempty" toml:"updated_at" yaml:"updated_at,omitempty"`
	DeletedAt       null.Time   `boil:"deleted_at" json:"deleted_at,omitempty" toml:"deleted_at" yaml:"deleted_at,omitempty"`

	R *rawSongInfoR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L rawSongInfoL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var RawSongInfoColumns = struct {
	RawSongInfoID   string
	SongNumber      string
	SongName        string
	ArtistName      string
	MelonSongID     string
	MelonArtistID   string
	MelonArtistName string
	Album           string
	Genre           string
	Lyrics          string
	LyricsSummary   string
	LyricsTags      string
	Year            string
	Country         string
	SingerType      string
	RelatedArtists  string
	CreatedAt       string
	UpdatedAt       string
	DeletedAt       string
}{
	RawSongInfoID:   "raw_song_info_id",
	SongNumber:      "song_number",
	SongName:        "song_name",
	ArtistName:      "artist_name",
	MelonSongID:     "melon_song_id",
	MelonArtistID:   "melon_artist_id",
	MelonArtistName: "melon_artist_name",
	Album:           "album",
	Genre:           "genre",
	Lyrics:          "lyrics",
	LyricsSummary:   "lyrics_summary",
	LyricsTags:      "lyrics_tags",
	Year:            "year",
	Country:         "country",
	SingerType:      "singer_type",
	RelatedArtists:  "related_artists",
	CreatedAt:       "created_at",
	UpdatedAt:       "updated_at",
	DeletedAt:       "deleted_at",
}

var RawSongInfoTableColumns = struct {
	RawSongInfoID   string
	SongNumber      string
	SongName        string
	ArtistName      string
	MelonSongID     string
	MelonArtistID   string
	MelonArtistName string
	Album           string
	Genre           string
	Lyrics          string
	LyricsSummary   string
	LyricsTags      string
	Year            string
	Country         string
	SingerType      string
	RelatedArtists  string
	CreatedAt       string
	UpdatedAt       string
	DeletedAt       string
}{
	RawSongInfoID:   "raw_song_info.raw_song_info_id",
	SongNumber:      "raw_song_info.song_number",
	SongName:        "raw_song_info.song_name",
	ArtistName:      "raw_song_info.artist_name",
	MelonSongID:     "raw_song_info.melon_song_id",
	MelonArtistID:   "raw_song_info.melon_artist_id",
	MelonArtistName: "raw_song_info.melon_artist_name",
	Album:           "raw_song_info.album",
	Genre:           "raw_song_info.genre",
	Lyrics:          "raw_song_info.lyrics",
	LyricsSummary:   "raw_song_info.lyrics_summary",
	LyricsTags:      "raw_song_info.lyrics_tags",
	Year:            "raw_song_info.year",
	Country:         "raw_song_info.country",
	SingerType:      "raw_song_info.singer_type",
	RelatedArtists:  "raw_song_info.related_artists",
	CreatedAt:       "raw_song_info.created_at",
	UpdatedAt:       "raw_song_info.updated_at",
	DeletedAt:       "raw_song_info.deleted_at",
}

// Generated where

var RawSongInfoWhere = struct {
	RawSongInfoID   whereHelperint64
	SongNumber      whereHelperint
	SongName        whereHelperstring
	ArtistName      whereHelperstring
	MelonSongID     whereHelpernull_String
	MelonArtistID   whereHelpernull_String
	MelonArtistName whereHelpernull_String
	Album           whereHelpernull_String
	Genre           whereHelpernull_String
	Lyrics          whereHelpernull_String
	LyricsSummary   whereHelpernull_String
	LyricsTags      whereHelpernull_String
	Year            whereHelpernull_String
	Country         whereHelpernull_String
	SingerType      whereHelpernull_String
	RelatedArtists  whereHelpernull_String
	CreatedAt       whereHelpernull_Time
	UpdatedAt       whereHelpernull_Time
	DeletedAt       whereHelpernull_Time
}{
	RawSongInfoID:   whereHelperint64{field: "`raw_song_info`.`raw_song_info_id`"},
	SongNumber:      whereHelperint{field: "`raw_song_info`.`song_number`"},
	SongName:        whereHelperstring{field: "`raw_song_info`.`song_name`"},
	ArtistName:      whereHelperstring{field: "`raw_song_info`.`artist_name`"},
	MelonSongID:     whereHelpernull_String{field: "`raw_song_info`.`melon_song_id`"},
	MelonArtistID:   whereHelpernull_String{field: "`raw_song_info`.`melon_artist_id`"},
	MelonArtistName: whereHelpernull_String{field: "`raw_song_info`.`melon_artist_name`"},
	Album:           whereHelpernull_String{field: "`raw_song_info`.`album`"},
	Genre:           whereHelpernull_String{field: "`raw_song_info`.`genre`"},
	Lyrics:          whereHelpernull_String{field: "`raw_song_info`.`lyrics`"},
	LyricsSummary:   whereHelpernull_String{field: "`raw_song_info`.`lyrics_summary`"},
	LyricsTags:      whereHelpernull_String{field: "`raw_song_info`.`lyrics_tags`"},
	Year:            whereHelpernull_String{field: "`raw_song_info`.`year`"},
	Country:         whereHelpernull_String{field: "`raw_song_info`.`country`"},
	SingerType:      whereHelpernull_String{field: "`raw_song_info`.`singer_type`"},
	RelatedArtists:  whereHelpernull_String{field: "`raw_song_info`.`related_artists`"},
	CreatedAt:       whereHelpernull_Time{field: "`raw_song_info`.`created_at`"},
	UpdatedAt:       whereHelpernull_Time{field: "`raw_song_info`.`updated_at`"},
	DeletedAt:       whereHelpernull_Time{field: "`raw_song_info`.`deleted_at`"},
}

// RawSongInfoRels is where relationship names are stored.
var RawSongInfoRels = struct {
}{}

// rawSongInfoR is where relationships are stored.
type rawSongInfoR struct {
}

// NewStruct creates a new relationship struct
func (*rawSongInfoR) NewStruct() *rawSongInfoR {
	return &rawSongInfoR{}
}

// rawSongInfoL is where Load methods for each relationship are stored.
type rawSongInfoL struct{}

var (
	rawSongInfoAllColumns            = []string{"raw_song_info_id", "song_number", "song_name", "artist_name", "melon_song_id", "melon_artist_id", "melon_artist_name", "album", "genre", "lyrics", "lyrics_summary", "lyrics_tags", "year", "country", "singer_type", "related_artists", "created_at", "updated_at", "deleted_at"}
	rawSongInfoColumnsWithoutDefault = []string{"song_number", "song_name", "artist_name", "melon_song_id", "melon_artist_id", "melon_artist_name", "album", "genre", "lyrics", "lyrics_summary", "lyrics_tags", "year", "country", "singer_type", "related_artists", "deleted_at"}
	rawSongInfoColumnsWithDefault    = []string{"raw_song_info_id", "created_at", "updated_at"}
	rawSongInfoPrimaryKeyColumns     = []string{"raw_song_info_id"}
	rawSongInfoGeneratedColumns      = []string{}
)

type (
	// RawSongInfoSlice is an alias for a slice of pointers to RawSongInfo.
	// This should almost always be used instead of []RawSongInfo.
	RawSongInfoSlice []*RawSongInfo
	// RawSongInfoHook is the signature for custom RawSongInfo hook methods
	RawSongInfoHook func(context.Context, boil.ContextExecutor, *RawSongInfo) error

	rawSongInfoQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	rawSongInfoType                 = reflect.TypeOf(&RawSongInfo{})
	rawSongInfoMapping              = queries.MakeStructMapping(rawSongInfoType)
	rawSongInfoPrimaryKeyMapping, _ = queries.BindMapping(rawSongInfoType, rawSongInfoMapping, rawSongInfoPrimaryKeyColumns)
	rawSongInfoInsertCacheMut       sync.RWMutex
	rawSongInfoInsertCache          = make(map[string]insertCache)
	rawSongInfoUpdateCacheMut       sync.RWMutex
	rawSongInfoUpdateCache          = make(map[string]updateCache)
	rawSongInfoUpsertCacheMut       sync.RWMutex
	rawSongInfoUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var rawSongInfoAfterSelectHooks []RawSongInfoHook

var rawSongInfoBeforeInsertHooks []RawSongInfoHook
var rawSongInfoAfterInsertHooks []RawSongInfoHook

var rawSongInfoBeforeUpdateHooks []RawSongInfoHook
var rawSongInfoAfterUpdateHooks []RawSongInfoHook

var rawSongInfoBeforeDeleteHooks []RawSongInfoHook
var rawSongInfoAfterDeleteHooks []RawSongInfoHook

var rawSongInfoBeforeUpsertHooks []RawSongInfoHook
var rawSongInfoAfterUpsertHooks []RawSongInfoHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *RawSongInfo) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range rawSongInfoAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *RawSongInfo) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range rawSongInfoBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *RawSongInfo) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range rawSongInfoAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *RawSongInfo) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range rawSongInfoBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *RawSongInfo) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range rawSongInfoAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *RawSongInfo) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range rawSongInfoBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *RawSongInfo) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range rawSongInfoAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *RawSongInfo) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range rawSongInfoBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *RawSongInfo) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range rawSongInfoAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddRawSongInfoHook registers your hook function for all future operations.
func AddRawSongInfoHook(hookPoint boil.HookPoint, rawSongInfoHook RawSongInfoHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		rawSongInfoAfterSelectHooks = append(rawSongInfoAfterSelectHooks, rawSongInfoHook)
	case boil.BeforeInsertHook:
		rawSongInfoBeforeInsertHooks = append(rawSongInfoBeforeInsertHooks, rawSongInfoHook)
	case boil.AfterInsertHook:
		rawSongInfoAfterInsertHooks = append(rawSongInfoAfterInsertHooks, rawSongInfoHook)
	case boil.BeforeUpdateHook:
		rawSongInfoBeforeUpdateHooks = append(rawSongInfoBeforeUpdateHooks, rawSongInfoHook)
	case boil.AfterUpdateHook:
		rawSongInfoAfterUpdateHooks = append(rawSongInfoAfterUpdateHooks, rawSongInfoHook)
	case boil.BeforeDeleteHook:
		rawSongInfoBeforeDeleteHooks = append(rawSongInfoBeforeDeleteHooks, rawSongInfoHook)
	case boil.AfterDeleteHook:
		rawSongInfoAfterDeleteHooks = append(rawSongInfoAfterDeleteHooks, rawSongInfoHook)
	case boil.BeforeUpsertHook:
		rawSongInfoBeforeUpsertHooks = append(rawSongInfoBeforeUpsertHooks, rawSongInfoHook)
	case boil.AfterUpsertHook:
		rawSongInfoAfterUpsertHooks = append(rawSongInfoAfterUpsertHooks, rawSongInfoHook)
	}
}

// One returns a single rawSongInfo record from the query.
func (q rawSongInfoQuery) One(ctx context.Context, exec boil.ContextExecutor) (*RawSongInfo, error) {
	o := &RawSongInfo{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "mysql: failed to execute a one query for raw_song_info")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all RawSongInfo records from the query.
func (q rawSongInfoQuery) All(ctx context.Context, exec boil.ContextExecutor) (RawSongInfoSlice, error) {
	var o []*RawSongInfo

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "mysql: failed to assign all query results to RawSongInfo slice")
	}

	if len(rawSongInfoAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all RawSongInfo records in the query.
func (q rawSongInfoQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "mysql: failed to count raw_song_info rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q rawSongInfoQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "mysql: failed to check if raw_song_info exists")
	}

	return count > 0, nil
}

// RawSongInfos retrieves all the records using an executor.
func RawSongInfos(mods ...qm.QueryMod) rawSongInfoQuery {
	mods = append(mods, qm.From("`raw_song_info`"))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"`raw_song_info`.*"})
	}

	return rawSongInfoQuery{q}
}

// FindRawSongInfo retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindRawSongInfo(ctx context.Context, exec boil.ContextExecutor, rawSongInfoID int64, selectCols ...string) (*RawSongInfo, error) {
	rawSongInfoObj := &RawSongInfo{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `raw_song_info` where `raw_song_info_id`=?", sel,
	)

	q := queries.Raw(query, rawSongInfoID)

	err := q.Bind(ctx, exec, rawSongInfoObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "mysql: unable to select from raw_song_info")
	}

	if err = rawSongInfoObj.doAfterSelectHooks(ctx, exec); err != nil {
		return rawSongInfoObj, err
	}

	return rawSongInfoObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *RawSongInfo) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("mysql: no raw_song_info provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(rawSongInfoColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	rawSongInfoInsertCacheMut.RLock()
	cache, cached := rawSongInfoInsertCache[key]
	rawSongInfoInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			rawSongInfoAllColumns,
			rawSongInfoColumnsWithDefault,
			rawSongInfoColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(rawSongInfoType, rawSongInfoMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(rawSongInfoType, rawSongInfoMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `raw_song_info` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `raw_song_info` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `raw_song_info` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, rawSongInfoPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "mysql: unable to insert into raw_song_info")
	}

	var lastID int64
	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.RawSongInfoID = int64(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == rawSongInfoMapping["raw_song_info_id"] {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.RawSongInfoID,
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, identifierCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "mysql: unable to populate default values for raw_song_info")
	}

CacheNoHooks:
	if !cached {
		rawSongInfoInsertCacheMut.Lock()
		rawSongInfoInsertCache[key] = cache
		rawSongInfoInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the RawSongInfo.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *RawSongInfo) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	rawSongInfoUpdateCacheMut.RLock()
	cache, cached := rawSongInfoUpdateCache[key]
	rawSongInfoUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			rawSongInfoAllColumns,
			rawSongInfoPrimaryKeyColumns,
		)
		if len(wl) == 0 {
			return 0, errors.New("mysql: unable to update raw_song_info, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `raw_song_info` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, rawSongInfoPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(rawSongInfoType, rawSongInfoMapping, append(wl, rawSongInfoPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "mysql: unable to update raw_song_info row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "mysql: failed to get rows affected by update for raw_song_info")
	}

	if !cached {
		rawSongInfoUpdateCacheMut.Lock()
		rawSongInfoUpdateCache[key] = cache
		rawSongInfoUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q rawSongInfoQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "mysql: unable to update all for raw_song_info")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "mysql: unable to retrieve rows affected for raw_song_info")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o RawSongInfoSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("mysql: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), rawSongInfoPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `raw_song_info` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, rawSongInfoPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "mysql: unable to update all in rawSongInfo slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "mysql: unable to retrieve rows affected all in update all rawSongInfo")
	}
	return rowsAff, nil
}

var mySQLRawSongInfoUniqueColumns = []string{
	"raw_song_info_id",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *RawSongInfo) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("mysql: no raw_song_info provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(rawSongInfoColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLRawSongInfoUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	rawSongInfoUpsertCacheMut.RLock()
	cache, cached := rawSongInfoUpsertCache[key]
	rawSongInfoUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, _ := insertColumns.InsertColumnSet(
			rawSongInfoAllColumns,
			rawSongInfoColumnsWithDefault,
			rawSongInfoColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			rawSongInfoAllColumns,
			rawSongInfoPrimaryKeyColumns,
		)

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("mysql: unable to upsert raw_song_info, could not build update column list")
		}

		ret := strmangle.SetComplement(rawSongInfoAllColumns, strmangle.SetIntersect(insert, update))

		cache.query = buildUpsertQueryMySQL(dialect, "`raw_song_info`", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `raw_song_info` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(rawSongInfoType, rawSongInfoMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(rawSongInfoType, rawSongInfoMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "mysql: unable to upsert for raw_song_info")
	}

	var lastID int64
	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.RawSongInfoID = int64(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == rawSongInfoMapping["raw_song_info_id"] {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(rawSongInfoType, rawSongInfoMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "mysql: unable to retrieve unique values for raw_song_info")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, nzUniqueCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "mysql: unable to populate default values for raw_song_info")
	}

CacheNoHooks:
	if !cached {
		rawSongInfoUpsertCacheMut.Lock()
		rawSongInfoUpsertCache[key] = cache
		rawSongInfoUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single RawSongInfo record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *RawSongInfo) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("mysql: no RawSongInfo provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), rawSongInfoPrimaryKeyMapping)
	sql := "DELETE FROM `raw_song_info` WHERE `raw_song_info_id`=?"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "mysql: unable to delete from raw_song_info")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "mysql: failed to get rows affected by delete for raw_song_info")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q rawSongInfoQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("mysql: no rawSongInfoQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "mysql: unable to delete all from raw_song_info")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "mysql: failed to get rows affected by deleteall for raw_song_info")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o RawSongInfoSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(rawSongInfoBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), rawSongInfoPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `raw_song_info` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, rawSongInfoPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "mysql: unable to delete all from rawSongInfo slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "mysql: failed to get rows affected by deleteall for raw_song_info")
	}

	if len(rawSongInfoAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *RawSongInfo) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindRawSongInfo(ctx, exec, o.RawSongInfoID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *RawSongInfoSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := RawSongInfoSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), rawSongInfoPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `raw_song_info`.* FROM `raw_song_info` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, rawSongInfoPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "mysql: unable to reload all in RawSongInfoSlice")
	}

	*o = slice

	return nil
}

// RawSongInfoExists checks if the RawSongInfo row exists.
func RawSongInfoExists(ctx context.Context, exec boil.ContextExecutor, rawSongInfoID int64) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `raw_song_info` where `raw_song_info_id`=? limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, rawSongInfoID)
	}
	row := exec.QueryRowContext(ctx, sql, rawSongInfoID)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "mysql: unable to check if raw_song_info exists")
	}

	return exists, nil
}

// Exists checks if the RawSongInfo row exists.
func (o *RawSongInfo) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return RawSongInfoExists(ctx, exec, o.RawSongInfoID)
}
