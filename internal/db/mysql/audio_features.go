// Code generated by SQLBoiler 4.15.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package mysql

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// AudioFeature is an object representing the database table.
type AudioFeature struct {
	ID                  int          `boil:"id" json:"id" toml:"id" yaml:"id"`
	SongID              null.Int     `boil:"song_id" json:"song_id,omitempty" toml:"song_id" yaml:"song_id,omitempty"`
	SongName            string       `boil:"song_name" json:"song_name" toml:"song_name" yaml:"song_name"`
	ArtistName          string       `boil:"artist_name" json:"artist_name" toml:"artist_name" yaml:"artist_name"`
	VideoLink           null.String  `boil:"video_link" json:"video_link,omitempty" toml:"video_link" yaml:"video_link,omitempty"`
	VideoTitle          null.String  `boil:"video_title" json:"video_title,omitempty" toml:"video_title" yaml:"video_title,omitempty"`
	Tempo               null.Float32 `boil:"tempo" json:"tempo,omitempty" toml:"tempo" yaml:"tempo,omitempty"`
	Key                 null.String  `boil:"key" json:"key,omitempty" toml:"key" yaml:"key,omitempty"`
	HighestNote         null.String  `boil:"highest_note" json:"highest_note,omitempty" toml:"highest_note" yaml:"highest_note,omitempty"`
	Loudness            null.Float32 `boil:"loudness" json:"loudness,omitempty" toml:"loudness" yaml:"loudness,omitempty"`
	Energy              null.Float32 `boil:"energy" json:"energy,omitempty" toml:"energy" yaml:"energy,omitempty"`
	Speechiness         null.Float32 `boil:"speechiness" json:"speechiness,omitempty" toml:"speechiness" yaml:"speechiness,omitempty"`
	Acousticness        null.Float32 `boil:"acousticness" json:"acousticness,omitempty" toml:"acousticness" yaml:"acousticness,omitempty"`
	Danceability        null.Float32 `boil:"danceability" json:"danceability,omitempty" toml:"danceability" yaml:"danceability,omitempty"`
	TimbreMFCCS         null.String  `boil:"timbre_mfccs" json:"timbre_mfccs,omitempty" toml:"timbre_mfccs" yaml:"timbre_mfccs,omitempty"`
	CreatedAt           null.Time    `boil:"created_at" json:"created_at,omitempty" toml:"created_at" yaml:"created_at,omitempty"`
	AudioFileURL        null.String  `boil:"audio_file_url" json:"audio_file_url,omitempty" toml:"audio_file_url" yaml:"audio_file_url,omitempty"`
	RMSEnergy           null.Float32 `boil:"rms_energy" json:"rms_energy,omitempty" toml:"rms_energy" yaml:"rms_energy,omitempty"`
	SpectralFlux        null.Float32 `boil:"spectral_flux" json:"spectral_flux,omitempty" toml:"spectral_flux" yaml:"spectral_flux,omitempty"`
	Instrumentalness    null.Float32 `boil:"instrumentalness" json:"instrumentalness,omitempty" toml:"instrumentalness" yaml:"instrumentalness,omitempty"`
	MFCCMean            null.String  `boil:"mfcc_mean" json:"mfcc_mean,omitempty" toml:"mfcc_mean" yaml:"mfcc_mean,omitempty"`
	PerceptualSharpness null.Float32 `boil:"perceptual_sharpness" json:"perceptual_sharpness,omitempty" toml:"perceptual_sharpness" yaml:"perceptual_sharpness,omitempty"`
	PerceptualSpread    null.Float32 `boil:"perceptual_spread" json:"perceptual_spread,omitempty" toml:"perceptual_spread" yaml:"perceptual_spread,omitempty"`
	OnsetEvents         null.Int     `boil:"onset_events" json:"onset_events,omitempty" toml:"onset_events" yaml:"onset_events,omitempty"`
	SpectralFlatness    null.Float32 `boil:"spectral_flatness" json:"spectral_flatness,omitempty" toml:"spectral_flatness" yaml:"spectral_flatness,omitempty"`
	AmplitudeEnvelope   null.Float32 `boil:"amplitude_envelope" json:"amplitude_envelope,omitempty" toml:"amplitude_envelope" yaml:"amplitude_envelope,omitempty"`
	SpectralSpread      null.Float32 `boil:"spectral_spread" json:"spectral_spread,omitempty" toml:"spectral_spread" yaml:"spectral_spread,omitempty"`
	HarmonicEnergy      null.Float32 `boil:"harmonic_energy" json:"harmonic_energy,omitempty" toml:"harmonic_energy" yaml:"harmonic_energy,omitempty"`
	NoteNumber          null.Int     `boil:"note_number" json:"note_number,omitempty" toml:"note_number" yaml:"note_number,omitempty"`
	MeanPitch           null.Float32 `boil:"mean_pitch" json:"mean_pitch,omitempty" toml:"mean_pitch" yaml:"mean_pitch,omitempty"`

	R *audioFeatureR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L audioFeatureL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var AudioFeatureColumns = struct {
	ID                  string
	SongID              string
	SongName            string
	ArtistName          string
	VideoLink           string
	VideoTitle          string
	Tempo               string
	Key                 string
	HighestNote         string
	Loudness            string
	Energy              string
	Speechiness         string
	Acousticness        string
	Danceability        string
	TimbreMFCCS         string
	CreatedAt           string
	AudioFileURL        string
	RMSEnergy           string
	SpectralFlux        string
	Instrumentalness    string
	MFCCMean            string
	PerceptualSharpness string
	PerceptualSpread    string
	OnsetEvents         string
	SpectralFlatness    string
	AmplitudeEnvelope   string
	SpectralSpread      string
	HarmonicEnergy      string
	NoteNumber          string
	MeanPitch           string
}{
	ID:                  "id",
	SongID:              "song_id",
	SongName:            "song_name",
	ArtistName:          "artist_name",
	VideoLink:           "video_link",
	VideoTitle:          "video_title",
	Tempo:               "tempo",
	Key:                 "key",
	HighestNote:         "highest_note",
	Loudness:            "loudness",
	Energy:              "energy",
	Speechiness:         "speechiness",
	Acousticness:        "acousticness",
	Danceability:        "danceability",
	TimbreMFCCS:         "timbre_mfccs",
	CreatedAt:           "created_at",
	AudioFileURL:        "audio_file_url",
	RMSEnergy:           "rms_energy",
	SpectralFlux:        "spectral_flux",
	Instrumentalness:    "instrumentalness",
	MFCCMean:            "mfcc_mean",
	PerceptualSharpness: "perceptual_sharpness",
	PerceptualSpread:    "perceptual_spread",
	OnsetEvents:         "onset_events",
	SpectralFlatness:    "spectral_flatness",
	AmplitudeEnvelope:   "amplitude_envelope",
	SpectralSpread:      "spectral_spread",
	HarmonicEnergy:      "harmonic_energy",
	NoteNumber:          "note_number",
	MeanPitch:           "mean_pitch",
}

var AudioFeatureTableColumns = struct {
	ID                  string
	SongID              string
	SongName            string
	ArtistName          string
	VideoLink           string
	VideoTitle          string
	Tempo               string
	Key                 string
	HighestNote         string
	Loudness            string
	Energy              string
	Speechiness         string
	Acousticness        string
	Danceability        string
	TimbreMFCCS         string
	CreatedAt           string
	AudioFileURL        string
	RMSEnergy           string
	SpectralFlux        string
	Instrumentalness    string
	MFCCMean            string
	PerceptualSharpness string
	PerceptualSpread    string
	OnsetEvents         string
	SpectralFlatness    string
	AmplitudeEnvelope   string
	SpectralSpread      string
	HarmonicEnergy      string
	NoteNumber          string
	MeanPitch           string
}{
	ID:                  "audio_features.id",
	SongID:              "audio_features.song_id",
	SongName:            "audio_features.song_name",
	ArtistName:          "audio_features.artist_name",
	VideoLink:           "audio_features.video_link",
	VideoTitle:          "audio_features.video_title",
	Tempo:               "audio_features.tempo",
	Key:                 "audio_features.key",
	HighestNote:         "audio_features.highest_note",
	Loudness:            "audio_features.loudness",
	Energy:              "audio_features.energy",
	Speechiness:         "audio_features.speechiness",
	Acousticness:        "audio_features.acousticness",
	Danceability:        "audio_features.danceability",
	TimbreMFCCS:         "audio_features.timbre_mfccs",
	CreatedAt:           "audio_features.created_at",
	AudioFileURL:        "audio_features.audio_file_url",
	RMSEnergy:           "audio_features.rms_energy",
	SpectralFlux:        "audio_features.spectral_flux",
	Instrumentalness:    "audio_features.instrumentalness",
	MFCCMean:            "audio_features.mfcc_mean",
	PerceptualSharpness: "audio_features.perceptual_sharpness",
	PerceptualSpread:    "audio_features.perceptual_spread",
	OnsetEvents:         "audio_features.onset_events",
	SpectralFlatness:    "audio_features.spectral_flatness",
	AmplitudeEnvelope:   "audio_features.amplitude_envelope",
	SpectralSpread:      "audio_features.spectral_spread",
	HarmonicEnergy:      "audio_features.harmonic_energy",
	NoteNumber:          "audio_features.note_number",
	MeanPitch:           "audio_features.mean_pitch",
}

// Generated where

type whereHelperint struct{ field string }

func (w whereHelperint) EQ(x int) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperint) NEQ(x int) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperint) LT(x int) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperint) LTE(x int) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperint) GT(x int) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperint) GTE(x int) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }
func (w whereHelperint) IN(slice []int) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelperint) NIN(slice []int) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

type whereHelpernull_Int struct{ field string }

func (w whereHelpernull_Int) EQ(x null.Int) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Int) NEQ(x null.Int) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Int) LT(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Int) LTE(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Int) GT(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Int) GTE(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}
func (w whereHelpernull_Int) IN(slice []int) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelpernull_Int) NIN(slice []int) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

func (w whereHelpernull_Int) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Int) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

type whereHelpernull_Float32 struct{ field string }

func (w whereHelpernull_Float32) EQ(x null.Float32) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Float32) NEQ(x null.Float32) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Float32) LT(x null.Float32) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Float32) LTE(x null.Float32) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Float32) GT(x null.Float32) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Float32) GTE(x null.Float32) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}
func (w whereHelpernull_Float32) IN(slice []float32) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelpernull_Float32) NIN(slice []float32) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

func (w whereHelpernull_Float32) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Float32) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

var AudioFeatureWhere = struct {
	ID                  whereHelperint
	SongID              whereHelpernull_Int
	SongName            whereHelperstring
	ArtistName          whereHelperstring
	VideoLink           whereHelpernull_String
	VideoTitle          whereHelpernull_String
	Tempo               whereHelpernull_Float32
	Key                 whereHelpernull_String
	HighestNote         whereHelpernull_String
	Loudness            whereHelpernull_Float32
	Energy              whereHelpernull_Float32
	Speechiness         whereHelpernull_Float32
	Acousticness        whereHelpernull_Float32
	Danceability        whereHelpernull_Float32
	TimbreMFCCS         whereHelpernull_String
	CreatedAt           whereHelpernull_Time
	AudioFileURL        whereHelpernull_String
	RMSEnergy           whereHelpernull_Float32
	SpectralFlux        whereHelpernull_Float32
	Instrumentalness    whereHelpernull_Float32
	MFCCMean            whereHelpernull_String
	PerceptualSharpness whereHelpernull_Float32
	PerceptualSpread    whereHelpernull_Float32
	OnsetEvents         whereHelpernull_Int
	SpectralFlatness    whereHelpernull_Float32
	AmplitudeEnvelope   whereHelpernull_Float32
	SpectralSpread      whereHelpernull_Float32
	HarmonicEnergy      whereHelpernull_Float32
	NoteNumber          whereHelpernull_Int
	MeanPitch           whereHelpernull_Float32
}{
	ID:                  whereHelperint{field: "`audio_features`.`id`"},
	SongID:              whereHelpernull_Int{field: "`audio_features`.`song_id`"},
	SongName:            whereHelperstring{field: "`audio_features`.`song_name`"},
	ArtistName:          whereHelperstring{field: "`audio_features`.`artist_name`"},
	VideoLink:           whereHelpernull_String{field: "`audio_features`.`video_link`"},
	VideoTitle:          whereHelpernull_String{field: "`audio_features`.`video_title`"},
	Tempo:               whereHelpernull_Float32{field: "`audio_features`.`tempo`"},
	Key:                 whereHelpernull_String{field: "`audio_features`.`key`"},
	HighestNote:         whereHelpernull_String{field: "`audio_features`.`highest_note`"},
	Loudness:            whereHelpernull_Float32{field: "`audio_features`.`loudness`"},
	Energy:              whereHelpernull_Float32{field: "`audio_features`.`energy`"},
	Speechiness:         whereHelpernull_Float32{field: "`audio_features`.`speechiness`"},
	Acousticness:        whereHelpernull_Float32{field: "`audio_features`.`acousticness`"},
	Danceability:        whereHelpernull_Float32{field: "`audio_features`.`danceability`"},
	TimbreMFCCS:         whereHelpernull_String{field: "`audio_features`.`timbre_mfccs`"},
	CreatedAt:           whereHelpernull_Time{field: "`audio_features`.`created_at`"},
	AudioFileURL:        whereHelpernull_String{field: "`audio_features`.`audio_file_url`"},
	RMSEnergy:           whereHelpernull_Float32{field: "`audio_features`.`rms_energy`"},
	SpectralFlux:        whereHelpernull_Float32{field: "`audio_features`.`spectral_flux`"},
	Instrumentalness:    whereHelpernull_Float32{field: "`audio_features`.`instrumentalness`"},
	MFCCMean:            whereHelpernull_String{field: "`audio_features`.`mfcc_mean`"},
	PerceptualSharpness: whereHelpernull_Float32{field: "`audio_features`.`perceptual_sharpness`"},
	PerceptualSpread:    whereHelpernull_Float32{field: "`audio_features`.`perceptual_spread`"},
	OnsetEvents:         whereHelpernull_Int{field: "`audio_features`.`onset_events`"},
	SpectralFlatness:    whereHelpernull_Float32{field: "`audio_features`.`spectral_flatness`"},
	AmplitudeEnvelope:   whereHelpernull_Float32{field: "`audio_features`.`amplitude_envelope`"},
	SpectralSpread:      whereHelpernull_Float32{field: "`audio_features`.`spectral_spread`"},
	HarmonicEnergy:      whereHelpernull_Float32{field: "`audio_features`.`harmonic_energy`"},
	NoteNumber:          whereHelpernull_Int{field: "`audio_features`.`note_number`"},
	MeanPitch:           whereHelpernull_Float32{field: "`audio_features`.`mean_pitch`"},
}

// AudioFeatureRels is where relationship names are stored.
var AudioFeatureRels = struct {
}{}

// audioFeatureR is where relationships are stored.
type audioFeatureR struct {
}

// NewStruct creates a new relationship struct
func (*audioFeatureR) NewStruct() *audioFeatureR {
	return &audioFeatureR{}
}

// audioFeatureL is where Load methods for each relationship are stored.
type audioFeatureL struct{}

var (
	audioFeatureAllColumns            = []string{"id", "song_id", "song_name", "artist_name", "video_link", "video_title", "tempo", "key", "highest_note", "loudness", "energy", "speechiness", "acousticness", "danceability", "timbre_mfccs", "created_at", "audio_file_url", "rms_energy", "spectral_flux", "instrumentalness", "mfcc_mean", "perceptual_sharpness", "perceptual_spread", "onset_events", "spectral_flatness", "amplitude_envelope", "spectral_spread", "harmonic_energy", "note_number", "mean_pitch"}
	audioFeatureColumnsWithoutDefault = []string{"song_id", "song_name", "artist_name", "video_link", "video_title", "tempo", "key", "highest_note", "loudness", "energy", "speechiness", "acousticness", "danceability", "timbre_mfccs", "audio_file_url", "rms_energy", "spectral_flux", "instrumentalness", "mfcc_mean", "perceptual_sharpness", "perceptual_spread", "onset_events", "spectral_flatness", "amplitude_envelope", "spectral_spread", "harmonic_energy", "note_number", "mean_pitch"}
	audioFeatureColumnsWithDefault    = []string{"id", "created_at"}
	audioFeaturePrimaryKeyColumns     = []string{"id"}
	audioFeatureGeneratedColumns      = []string{}
)

type (
	// AudioFeatureSlice is an alias for a slice of pointers to AudioFeature.
	// This should almost always be used instead of []AudioFeature.
	AudioFeatureSlice []*AudioFeature
	// AudioFeatureHook is the signature for custom AudioFeature hook methods
	AudioFeatureHook func(context.Context, boil.ContextExecutor, *AudioFeature) error

	audioFeatureQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	audioFeatureType                 = reflect.TypeOf(&AudioFeature{})
	audioFeatureMapping              = queries.MakeStructMapping(audioFeatureType)
	audioFeaturePrimaryKeyMapping, _ = queries.BindMapping(audioFeatureType, audioFeatureMapping, audioFeaturePrimaryKeyColumns)
	audioFeatureInsertCacheMut       sync.RWMutex
	audioFeatureInsertCache          = make(map[string]insertCache)
	audioFeatureUpdateCacheMut       sync.RWMutex
	audioFeatureUpdateCache          = make(map[string]updateCache)
	audioFeatureUpsertCacheMut       sync.RWMutex
	audioFeatureUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var audioFeatureAfterSelectHooks []AudioFeatureHook

var audioFeatureBeforeInsertHooks []AudioFeatureHook
var audioFeatureAfterInsertHooks []AudioFeatureHook

var audioFeatureBeforeUpdateHooks []AudioFeatureHook
var audioFeatureAfterUpdateHooks []AudioFeatureHook

var audioFeatureBeforeDeleteHooks []AudioFeatureHook
var audioFeatureAfterDeleteHooks []AudioFeatureHook

var audioFeatureBeforeUpsertHooks []AudioFeatureHook
var audioFeatureAfterUpsertHooks []AudioFeatureHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *AudioFeature) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range audioFeatureAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *AudioFeature) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range audioFeatureBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *AudioFeature) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range audioFeatureAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *AudioFeature) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range audioFeatureBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *AudioFeature) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range audioFeatureAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *AudioFeature) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range audioFeatureBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *AudioFeature) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range audioFeatureAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *AudioFeature) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range audioFeatureBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *AudioFeature) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range audioFeatureAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddAudioFeatureHook registers your hook function for all future operations.
func AddAudioFeatureHook(hookPoint boil.HookPoint, audioFeatureHook AudioFeatureHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		audioFeatureAfterSelectHooks = append(audioFeatureAfterSelectHooks, audioFeatureHook)
	case boil.BeforeInsertHook:
		audioFeatureBeforeInsertHooks = append(audioFeatureBeforeInsertHooks, audioFeatureHook)
	case boil.AfterInsertHook:
		audioFeatureAfterInsertHooks = append(audioFeatureAfterInsertHooks, audioFeatureHook)
	case boil.BeforeUpdateHook:
		audioFeatureBeforeUpdateHooks = append(audioFeatureBeforeUpdateHooks, audioFeatureHook)
	case boil.AfterUpdateHook:
		audioFeatureAfterUpdateHooks = append(audioFeatureAfterUpdateHooks, audioFeatureHook)
	case boil.BeforeDeleteHook:
		audioFeatureBeforeDeleteHooks = append(audioFeatureBeforeDeleteHooks, audioFeatureHook)
	case boil.AfterDeleteHook:
		audioFeatureAfterDeleteHooks = append(audioFeatureAfterDeleteHooks, audioFeatureHook)
	case boil.BeforeUpsertHook:
		audioFeatureBeforeUpsertHooks = append(audioFeatureBeforeUpsertHooks, audioFeatureHook)
	case boil.AfterUpsertHook:
		audioFeatureAfterUpsertHooks = append(audioFeatureAfterUpsertHooks, audioFeatureHook)
	}
}

// One returns a single audioFeature record from the query.
func (q audioFeatureQuery) One(ctx context.Context, exec boil.ContextExecutor) (*AudioFeature, error) {
	o := &AudioFeature{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "mysql: failed to execute a one query for audio_features")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all AudioFeature records from the query.
func (q audioFeatureQuery) All(ctx context.Context, exec boil.ContextExecutor) (AudioFeatureSlice, error) {
	var o []*AudioFeature

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "mysql: failed to assign all query results to AudioFeature slice")
	}

	if len(audioFeatureAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all AudioFeature records in the query.
func (q audioFeatureQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "mysql: failed to count audio_features rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q audioFeatureQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "mysql: failed to check if audio_features exists")
	}

	return count > 0, nil
}

// AudioFeatures retrieves all the records using an executor.
func AudioFeatures(mods ...qm.QueryMod) audioFeatureQuery {
	mods = append(mods, qm.From("`audio_features`"))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"`audio_features`.*"})
	}

	return audioFeatureQuery{q}
}

// FindAudioFeature retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindAudioFeature(ctx context.Context, exec boil.ContextExecutor, iD int, selectCols ...string) (*AudioFeature, error) {
	audioFeatureObj := &AudioFeature{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `audio_features` where `id`=?", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, audioFeatureObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "mysql: unable to select from audio_features")
	}

	if err = audioFeatureObj.doAfterSelectHooks(ctx, exec); err != nil {
		return audioFeatureObj, err
	}

	return audioFeatureObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *AudioFeature) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("mysql: no audio_features provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(audioFeatureColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	audioFeatureInsertCacheMut.RLock()
	cache, cached := audioFeatureInsertCache[key]
	audioFeatureInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			audioFeatureAllColumns,
			audioFeatureColumnsWithDefault,
			audioFeatureColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(audioFeatureType, audioFeatureMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(audioFeatureType, audioFeatureMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `audio_features` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `audio_features` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `audio_features` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, audioFeaturePrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "mysql: unable to insert into audio_features")
	}

	var lastID int64
	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ID = int(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == audioFeatureMapping["id"] {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.ID,
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, identifierCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "mysql: unable to populate default values for audio_features")
	}

CacheNoHooks:
	if !cached {
		audioFeatureInsertCacheMut.Lock()
		audioFeatureInsertCache[key] = cache
		audioFeatureInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the AudioFeature.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *AudioFeature) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	audioFeatureUpdateCacheMut.RLock()
	cache, cached := audioFeatureUpdateCache[key]
	audioFeatureUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			audioFeatureAllColumns,
			audioFeaturePrimaryKeyColumns,
		)
		if len(wl) == 0 {
			return 0, errors.New("mysql: unable to update audio_features, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `audio_features` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, audioFeaturePrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(audioFeatureType, audioFeatureMapping, append(wl, audioFeaturePrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "mysql: unable to update audio_features row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "mysql: failed to get rows affected by update for audio_features")
	}

	if !cached {
		audioFeatureUpdateCacheMut.Lock()
		audioFeatureUpdateCache[key] = cache
		audioFeatureUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q audioFeatureQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "mysql: unable to update all for audio_features")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "mysql: unable to retrieve rows affected for audio_features")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o AudioFeatureSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("mysql: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), audioFeaturePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `audio_features` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, audioFeaturePrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "mysql: unable to update all in audioFeature slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "mysql: unable to retrieve rows affected all in update all audioFeature")
	}
	return rowsAff, nil
}

var mySQLAudioFeatureUniqueColumns = []string{
	"id",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *AudioFeature) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("mysql: no audio_features provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(audioFeatureColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLAudioFeatureUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	audioFeatureUpsertCacheMut.RLock()
	cache, cached := audioFeatureUpsertCache[key]
	audioFeatureUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			audioFeatureAllColumns,
			audioFeatureColumnsWithDefault,
			audioFeatureColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			audioFeatureAllColumns,
			audioFeaturePrimaryKeyColumns,
		)

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("mysql: unable to upsert audio_features, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "`audio_features`", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `audio_features` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(audioFeatureType, audioFeatureMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(audioFeatureType, audioFeatureMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "mysql: unable to upsert for audio_features")
	}

	var lastID int64
	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ID = int(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == audioFeatureMapping["id"] {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(audioFeatureType, audioFeatureMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "mysql: unable to retrieve unique values for audio_features")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, nzUniqueCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "mysql: unable to populate default values for audio_features")
	}

CacheNoHooks:
	if !cached {
		audioFeatureUpsertCacheMut.Lock()
		audioFeatureUpsertCache[key] = cache
		audioFeatureUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single AudioFeature record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *AudioFeature) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("mysql: no AudioFeature provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), audioFeaturePrimaryKeyMapping)
	sql := "DELETE FROM `audio_features` WHERE `id`=?"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "mysql: unable to delete from audio_features")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "mysql: failed to get rows affected by delete for audio_features")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q audioFeatureQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("mysql: no audioFeatureQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "mysql: unable to delete all from audio_features")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "mysql: failed to get rows affected by deleteall for audio_features")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o AudioFeatureSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(audioFeatureBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), audioFeaturePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `audio_features` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, audioFeaturePrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "mysql: unable to delete all from audioFeature slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "mysql: failed to get rows affected by deleteall for audio_features")
	}

	if len(audioFeatureAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *AudioFeature) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindAudioFeature(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *AudioFeatureSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := AudioFeatureSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), audioFeaturePrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `audio_features`.* FROM `audio_features` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, audioFeaturePrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "mysql: unable to reload all in AudioFeatureSlice")
	}

	*o = slice

	return nil
}

// AudioFeatureExists checks if the AudioFeature row exists.
func AudioFeatureExists(ctx context.Context, exec boil.ContextExecutor, iD int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `audio_features` where `id`=? limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "mysql: unable to check if audio_features exists")
	}

	return exists, nil
}

// Exists checks if the AudioFeature row exists.
func (o *AudioFeature) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return AudioFeatureExists(ctx, exec, o.ID)
}
